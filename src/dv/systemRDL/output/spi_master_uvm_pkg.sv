//---------------------------------------------------------------------------------
// This file was autogenerated by PeakRDL-uvm
// Date (mm-dd-yyyy) : 02-10-2022  
// Time (hh:mm:ss)   : 00:23:02
//---------------------------------------------------------------------------------

package spi_master_uvm_pkg;
    `include "uvm_macros.svh"
    import uvm_pkg::*;
    
    //-----------------------------------------------------------------------------
    // Reg - spi_master_apb_if.status
    //-----------------------------------------------------------------------------
    class spi_master_apb_if__status extends uvm_reg;
        `uvm_object_utils(spi_master_apb_if__status)
        
             uvm_reg_field RESERVED12;
        rand uvm_reg_field CS;
             uvm_reg_field RESERVED5;
        rand uvm_reg_field SRST;
        rand uvm_reg_field QWR;
        rand uvm_reg_field QRD;
        rand uvm_reg_field WR;
        rand uvm_reg_field RD;
        
        // Covergroup
        covergroup cg_vals;
            CS : coverpoint CS.value[3:0];
            SRST : coverpoint SRST.value[0];
            QWR : coverpoint QWR.value[0];
            QRD : coverpoint QRD.value[0];
            WR : coverpoint WR.value[0];
            RD : coverpoint RD.value[0];
        endgroup

        // Function: new
        function new(string name = "spi_master_apb_if__status");
            super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
            add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
            if(has_coverage(UVM_CVR_FIELD_VALS)) begin
               cg_vals = new();
               cg_vals.set_inst_name(name);
            end
        endfunction : new
        
        // Function: sample_values
        virtual function void sample_values();
            super.sample_values();
            if (get_coverage(UVM_CVR_FIELD_VALS))
               cg_vals.sample();
        endfunction

        // Function: sample
        // This method is automatically invoked by the register abstraction class
        // whenever it is read or written with the specified ~data~
        // via the specified address ~map~
        protected virtual function void sample(uvm_reg_data_t data,
                                               uvm_reg_data_t byte_en,
                                               bit is_read,
                                               uvm_reg_map map);
            super.sample(data,byte_en,is_read,map);   
            
            foreach (m_fields[i])
               m_fields[i].value = ((data >> m_fields[i].get_lsb_pos()) &
                                    ((1 << m_fields[i].get_n_bits()) - 1));
         
            sample_values();
        endfunction

        // Function: build
        virtual function void build();
            this.RESERVED12 = uvm_reg_field::type_id::create("RESERVED12");
            
            this.CS = uvm_reg_field::type_id::create("CS");
            this.CS.configure( 
                                  .parent(this),
                                  .size(4),
                                  .lsb_pos(8),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(4'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
            this.RESERVED5 = uvm_reg_field::type_id::create("RESERVED5");
            
            this.SRST = uvm_reg_field::type_id::create("SRST");
            this.SRST.configure( 
                                  .parent(this),
                                  .size(1),
                                  .lsb_pos(4),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(1'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
            this.QWR = uvm_reg_field::type_id::create("QWR");
            this.QWR.configure( 
                                  .parent(this),
                                  .size(1),
                                  .lsb_pos(3),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(1'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
            this.QRD = uvm_reg_field::type_id::create("QRD");
            this.QRD.configure( 
                                  .parent(this),
                                  .size(1),
                                  .lsb_pos(2),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(1'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
            this.WR = uvm_reg_field::type_id::create("WR");
            this.WR.configure( 
                                  .parent(this),
                                  .size(1),
                                  .lsb_pos(1),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(1'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
            this.RD = uvm_reg_field::type_id::create("RD");
            this.RD.configure( 
                                  .parent(this),
                                  .size(1),
                                  .lsb_pos(0),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(1'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
        endfunction : build
    endclass : spi_master_apb_if__status

    //-----------------------------------------------------------------------------
    // Reg - spi_master_apb_if.clkdiv
    //-----------------------------------------------------------------------------
    class spi_master_apb_if__clkdiv extends uvm_reg;
        `uvm_object_utils(spi_master_apb_if__clkdiv)
        
             uvm_reg_field RESERVED8;
        rand uvm_reg_field CLKDIV;
        
        // Covergroup
        covergroup cg_vals;
            CLKDIV : coverpoint CLKDIV.value[7:0];
        endgroup

        // Function: new
        function new(string name = "spi_master_apb_if__clkdiv");
            super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
            add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
            if(has_coverage(UVM_CVR_FIELD_VALS)) begin
               cg_vals = new();
               cg_vals.set_inst_name(name);
            end
        endfunction : new
        
        // Function: sample_values
        virtual function void sample_values();
            super.sample_values();
            if (get_coverage(UVM_CVR_FIELD_VALS))
               cg_vals.sample();
        endfunction

        // Function: sample
        // This method is automatically invoked by the register abstraction class
        // whenever it is read or written with the specified ~data~
        // via the specified address ~map~
        protected virtual function void sample(uvm_reg_data_t data,
                                               uvm_reg_data_t byte_en,
                                               bit is_read,
                                               uvm_reg_map map);
            super.sample(data,byte_en,is_read,map);   
            
            foreach (m_fields[i])
               m_fields[i].value = ((data >> m_fields[i].get_lsb_pos()) &
                                    ((1 << m_fields[i].get_n_bits()) - 1));
         
            sample_values();
        endfunction

        // Function: build
        virtual function void build();
            this.RESERVED8 = uvm_reg_field::type_id::create("RESERVED8");
            
            this.CLKDIV = uvm_reg_field::type_id::create("CLKDIV");
            this.CLKDIV.configure( 
                                  .parent(this),
                                  .size(8),
                                  .lsb_pos(0),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(8'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
        endfunction : build
    endclass : spi_master_apb_if__clkdiv

    //-----------------------------------------------------------------------------
    // Reg - spi_master_apb_if.spicmd
    //-----------------------------------------------------------------------------
    class spi_master_apb_if__spicmd extends uvm_reg;
        `uvm_object_utils(spi_master_apb_if__spicmd)
        
        rand uvm_reg_field SPICMD;
        
        // Covergroup
        covergroup cg_vals;
            SPICMD : coverpoint SPICMD.value[31:0];
        endgroup

        // Function: new
        function new(string name = "spi_master_apb_if__spicmd");
            super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
            add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
            if(has_coverage(UVM_CVR_FIELD_VALS)) begin
               cg_vals = new();
               cg_vals.set_inst_name(name);
            end
        endfunction : new
        
        // Function: sample_values
        virtual function void sample_values();
            super.sample_values();
            if (get_coverage(UVM_CVR_FIELD_VALS))
               cg_vals.sample();
        endfunction

        // Function: sample
        // This method is automatically invoked by the register abstraction class
        // whenever it is read or written with the specified ~data~
        // via the specified address ~map~
        protected virtual function void sample(uvm_reg_data_t data,
                                               uvm_reg_data_t byte_en,
                                               bit is_read,
                                               uvm_reg_map map);
            super.sample(data,byte_en,is_read,map);   
            
            foreach (m_fields[i])
               m_fields[i].value = ((data >> m_fields[i].get_lsb_pos()) &
                                    ((1 << m_fields[i].get_n_bits()) - 1));
         
            sample_values();
        endfunction

        // Function: build
        virtual function void build();
            this.SPICMD = uvm_reg_field::type_id::create("SPICMD");
            this.SPICMD.configure( 
                                  .parent(this),
                                  .size(32),
                                  .lsb_pos(0),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(32'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
        endfunction : build
    endclass : spi_master_apb_if__spicmd

    //-----------------------------------------------------------------------------
    // Reg - spi_master_apb_if.spiadr
    //-----------------------------------------------------------------------------
    class spi_master_apb_if__spiadr extends uvm_reg;
        `uvm_object_utils(spi_master_apb_if__spiadr)
        
        rand uvm_reg_field SPIADR;
        
        // Covergroup
        covergroup cg_vals;
            SPIADR : coverpoint SPIADR.value[31:0];
        endgroup

        // Function: new
        function new(string name = "spi_master_apb_if__spiadr");
            super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
            add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
            if(has_coverage(UVM_CVR_FIELD_VALS)) begin
               cg_vals = new();
               cg_vals.set_inst_name(name);
            end
        endfunction : new
        
        // Function: sample_values
        virtual function void sample_values();
            super.sample_values();
            if (get_coverage(UVM_CVR_FIELD_VALS))
               cg_vals.sample();
        endfunction

        // Function: sample
        // This method is automatically invoked by the register abstraction class
        // whenever it is read or written with the specified ~data~
        // via the specified address ~map~
        protected virtual function void sample(uvm_reg_data_t data,
                                               uvm_reg_data_t byte_en,
                                               bit is_read,
                                               uvm_reg_map map);
            super.sample(data,byte_en,is_read,map);   
            
            foreach (m_fields[i])
               m_fields[i].value = ((data >> m_fields[i].get_lsb_pos()) &
                                    ((1 << m_fields[i].get_n_bits()) - 1));
         
            sample_values();
        endfunction

        // Function: build
        virtual function void build();
            this.SPIADR = uvm_reg_field::type_id::create("SPIADR");
            this.SPIADR.configure( 
                                  .parent(this),
                                  .size(32),
                                  .lsb_pos(0),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(32'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
        endfunction : build
    endclass : spi_master_apb_if__spiadr

    //-----------------------------------------------------------------------------
    // Reg - spi_master_apb_if.spilen
    //-----------------------------------------------------------------------------
    class spi_master_apb_if__spilen extends uvm_reg;
        `uvm_object_utils(spi_master_apb_if__spilen)
        
        rand uvm_reg_field DATALEN;
             uvm_reg_field RESERVED14;
        rand uvm_reg_field ADDRLEN;
             uvm_reg_field RESERVED6;
        rand uvm_reg_field CMDLEN;
        
        // Covergroup
        covergroup cg_vals;
            DATALEN : coverpoint DATALEN.value[15:0];
            ADDRLEN : coverpoint ADDRLEN.value[5:0];
            CMDLEN : coverpoint CMDLEN.value[5:0];
        endgroup

        // Function: new
        function new(string name = "spi_master_apb_if__spilen");
            super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
            add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
            if(has_coverage(UVM_CVR_FIELD_VALS)) begin
               cg_vals = new();
               cg_vals.set_inst_name(name);
            end
        endfunction : new
        
        // Function: sample_values
        virtual function void sample_values();
            super.sample_values();
            if (get_coverage(UVM_CVR_FIELD_VALS))
               cg_vals.sample();
        endfunction

        // Function: sample
        // This method is automatically invoked by the register abstraction class
        // whenever it is read or written with the specified ~data~
        // via the specified address ~map~
        protected virtual function void sample(uvm_reg_data_t data,
                                               uvm_reg_data_t byte_en,
                                               bit is_read,
                                               uvm_reg_map map);
            super.sample(data,byte_en,is_read,map);   
            
            foreach (m_fields[i])
               m_fields[i].value = ((data >> m_fields[i].get_lsb_pos()) &
                                    ((1 << m_fields[i].get_n_bits()) - 1));
         
            sample_values();
        endfunction

        // Function: build
        virtual function void build();
            this.DATALEN = uvm_reg_field::type_id::create("DATALEN");
            this.DATALEN.configure( 
                                  .parent(this),
                                  .size(16),
                                  .lsb_pos(16),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(16'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
            this.RESERVED14 = uvm_reg_field::type_id::create("RESERVED14");
            
            this.ADDRLEN = uvm_reg_field::type_id::create("ADDRLEN");
            this.ADDRLEN.configure( 
                                  .parent(this),
                                  .size(6),
                                  .lsb_pos(8),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(6'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
            this.RESERVED6 = uvm_reg_field::type_id::create("RESERVED6");
            
            this.CMDLEN = uvm_reg_field::type_id::create("CMDLEN");
            this.CMDLEN.configure( 
                                  .parent(this),
                                  .size(6),
                                  .lsb_pos(0),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(6'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
        endfunction : build
    endclass : spi_master_apb_if__spilen

    //-----------------------------------------------------------------------------
    // Reg - spi_master_apb_if.spidum
    //-----------------------------------------------------------------------------
    class spi_master_apb_if__spidum extends uvm_reg;
        `uvm_object_utils(spi_master_apb_if__spidum)
        
        rand uvm_reg_field DUMMYWR;
        rand uvm_reg_field DUMMYRD;
        
        // Covergroup
        covergroup cg_vals;
            DUMMYWR : coverpoint DUMMYWR.value[15:0];
            DUMMYRD : coverpoint DUMMYRD.value[15:0];
        endgroup

        // Function: new
        function new(string name = "spi_master_apb_if__spidum");
            super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
            add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
            if(has_coverage(UVM_CVR_FIELD_VALS)) begin
               cg_vals = new();
               cg_vals.set_inst_name(name);
            end
        endfunction : new
        
        // Function: sample_values
        virtual function void sample_values();
            super.sample_values();
            if (get_coverage(UVM_CVR_FIELD_VALS))
               cg_vals.sample();
        endfunction

        // Function: sample
        // This method is automatically invoked by the register abstraction class
        // whenever it is read or written with the specified ~data~
        // via the specified address ~map~
        protected virtual function void sample(uvm_reg_data_t data,
                                               uvm_reg_data_t byte_en,
                                               bit is_read,
                                               uvm_reg_map map);
            super.sample(data,byte_en,is_read,map);   
            
            foreach (m_fields[i])
               m_fields[i].value = ((data >> m_fields[i].get_lsb_pos()) &
                                    ((1 << m_fields[i].get_n_bits()) - 1));
         
            sample_values();
        endfunction

        // Function: build
        virtual function void build();
            this.DUMMYWR = uvm_reg_field::type_id::create("DUMMYWR");
            this.DUMMYWR.configure( 
                                  .parent(this),
                                  .size(16),
                                  .lsb_pos(16),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(16'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
            this.DUMMYRD = uvm_reg_field::type_id::create("DUMMYRD");
            this.DUMMYRD.configure( 
                                  .parent(this),
                                  .size(16),
                                  .lsb_pos(0),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(16'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
        endfunction : build
    endclass : spi_master_apb_if__spidum

    //-----------------------------------------------------------------------------
    // Reg - spi_master_apb_if.txfifo
    //-----------------------------------------------------------------------------
    class spi_master_apb_if__txfifo extends uvm_reg;
        `uvm_object_utils(spi_master_apb_if__txfifo)
        
        rand uvm_reg_field TX;
        
        // Covergroup
        covergroup cg_vals;
            TX : coverpoint TX.value[31:0];
        endgroup

        // Function: new
        function new(string name = "spi_master_apb_if__txfifo");
            super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
            add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
            if(has_coverage(UVM_CVR_FIELD_VALS)) begin
               cg_vals = new();
               cg_vals.set_inst_name(name);
            end
        endfunction : new
        
        // Function: sample_values
        virtual function void sample_values();
            super.sample_values();
            if (get_coverage(UVM_CVR_FIELD_VALS))
               cg_vals.sample();
        endfunction

        // Function: sample
        // This method is automatically invoked by the register abstraction class
        // whenever it is read or written with the specified ~data~
        // via the specified address ~map~
        protected virtual function void sample(uvm_reg_data_t data,
                                               uvm_reg_data_t byte_en,
                                               bit is_read,
                                               uvm_reg_map map);
            super.sample(data,byte_en,is_read,map);   
            
            foreach (m_fields[i])
               m_fields[i].value = ((data >> m_fields[i].get_lsb_pos()) &
                                    ((1 << m_fields[i].get_n_bits()) - 1));
         
            sample_values();
        endfunction

        // Function: build
        virtual function void build();
            this.TX = uvm_reg_field::type_id::create("TX");
            this.TX.configure( 
                                  .parent(this),
                                  .size(32),
                                  .lsb_pos(0),
                                  .access("WO"),
                                  .volatile(0),
                                  .reset(32'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
        endfunction : build
    endclass : spi_master_apb_if__txfifo

    //-----------------------------------------------------------------------------
    // Reg - spi_master_apb_if.rxfifo
    //-----------------------------------------------------------------------------
    class spi_master_apb_if__rxfifo extends uvm_reg;
        `uvm_object_utils(spi_master_apb_if__rxfifo)
        
        rand uvm_reg_field RX;
        
        // Covergroup
        covergroup cg_vals;
            RX : coverpoint RX.value[31:0];
        endgroup

        // Function: new
        function new(string name = "spi_master_apb_if__rxfifo");
            super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
            add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
            if(has_coverage(UVM_CVR_FIELD_VALS)) begin
               cg_vals = new();
               cg_vals.set_inst_name(name);
            end
        endfunction : new
        
        // Function: sample_values
        virtual function void sample_values();
            super.sample_values();
            if (get_coverage(UVM_CVR_FIELD_VALS))
               cg_vals.sample();
        endfunction

        // Function: sample
        // This method is automatically invoked by the register abstraction class
        // whenever it is read or written with the specified ~data~
        // via the specified address ~map~
        protected virtual function void sample(uvm_reg_data_t data,
                                               uvm_reg_data_t byte_en,
                                               bit is_read,
                                               uvm_reg_map map);
            super.sample(data,byte_en,is_read,map);   
            
            foreach (m_fields[i])
               m_fields[i].value = ((data >> m_fields[i].get_lsb_pos()) &
                                    ((1 << m_fields[i].get_n_bits()) - 1));
         
            sample_values();
        endfunction

        // Function: build
        virtual function void build();
            this.RX = uvm_reg_field::type_id::create("RX");
            this.RX.configure( 
                                  .parent(this),
                                  .size(32),
                                  .lsb_pos(0),
                                  .access("RO"),
                                  .volatile(1),
                                  .reset(32'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
        endfunction : build
    endclass : spi_master_apb_if__rxfifo

    //-----------------------------------------------------------------------------
    // Reg - spi_master_apb_if.intcfg
    //-----------------------------------------------------------------------------
    class spi_master_apb_if__intcfg extends uvm_reg;
        `uvm_object_utils(spi_master_apb_if__intcfg)
        
        rand uvm_reg_field EN;
        rand uvm_reg_field CNTEN;
             uvm_reg_field RESERVED29;
        rand uvm_reg_field CNTRX;
             uvm_reg_field RESERVED21;
        rand uvm_reg_field CNTTX;
             uvm_reg_field RESERVED13;
        rand uvm_reg_field RHTX;
             uvm_reg_field RESERVED5;
        rand uvm_reg_field THTX;
        
        // Covergroup
        covergroup cg_vals;
            EN : coverpoint EN.value[0];
            CNTEN : coverpoint CNTEN.value[0];
            CNTRX : coverpoint CNTRX.value[4:0];
            CNTTX : coverpoint CNTTX.value[4:0];
            RHTX : coverpoint RHTX.value[4:0];
            THTX : coverpoint THTX.value[4:0];
        endgroup

        // Function: new
        function new(string name = "spi_master_apb_if__intcfg");
            super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
            add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
            if(has_coverage(UVM_CVR_FIELD_VALS)) begin
               cg_vals = new();
               cg_vals.set_inst_name(name);
            end
        endfunction : new
        
        // Function: sample_values
        virtual function void sample_values();
            super.sample_values();
            if (get_coverage(UVM_CVR_FIELD_VALS))
               cg_vals.sample();
        endfunction

        // Function: sample
        // This method is automatically invoked by the register abstraction class
        // whenever it is read or written with the specified ~data~
        // via the specified address ~map~
        protected virtual function void sample(uvm_reg_data_t data,
                                               uvm_reg_data_t byte_en,
                                               bit is_read,
                                               uvm_reg_map map);
            super.sample(data,byte_en,is_read,map);   
            
            foreach (m_fields[i])
               m_fields[i].value = ((data >> m_fields[i].get_lsb_pos()) &
                                    ((1 << m_fields[i].get_n_bits()) - 1));
         
            sample_values();
        endfunction

        // Function: build
        virtual function void build();
            this.EN = uvm_reg_field::type_id::create("EN");
            this.EN.configure( 
                                  .parent(this),
                                  .size(1),
                                  .lsb_pos(31),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(1'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
            this.CNTEN = uvm_reg_field::type_id::create("CNTEN");
            this.CNTEN.configure( 
                                  .parent(this),
                                  .size(1),
                                  .lsb_pos(30),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(1'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
            this.RESERVED29 = uvm_reg_field::type_id::create("RESERVED29");
            
            this.CNTRX = uvm_reg_field::type_id::create("CNTRX");
            this.CNTRX.configure( 
                                  .parent(this),
                                  .size(5),
                                  .lsb_pos(24),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(5'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
            this.RESERVED21 = uvm_reg_field::type_id::create("RESERVED21");
            
            this.CNTTX = uvm_reg_field::type_id::create("CNTTX");
            this.CNTTX.configure( 
                                  .parent(this),
                                  .size(5),
                                  .lsb_pos(16),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(5'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
            this.RESERVED13 = uvm_reg_field::type_id::create("RESERVED13");
            
            this.RHTX = uvm_reg_field::type_id::create("RHTX");
            this.RHTX.configure( 
                                  .parent(this),
                                  .size(5),
                                  .lsb_pos(8),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(5'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
            this.RESERVED5 = uvm_reg_field::type_id::create("RESERVED5");
            
            this.THTX = uvm_reg_field::type_id::create("THTX");
            this.THTX.configure( 
                                  .parent(this),
                                  .size(5),
                                  .lsb_pos(0),
                                  .access("RW"),
                                  .volatile(0),
                                  .reset(5'h0),
                                  .has_reset(1),
                                  .is_rand(1),
                                  .individually_accessible(0));
            
        endfunction : build
    endclass : spi_master_apb_if__intcfg

    //-----------------------------------------------------------------------------
    // Addrmap - spi_master_apb_if_coverage
    //-----------------------------------------------------------------------------
    class spi_master_apb_if_coverage extends uvm_object;
        `uvm_object_utils(spi_master_apb_if_coverage)

        // Covergroup: ra_cov
        covergroup ra_cov(string name) with function sample(uvm_reg_addr_t addr, bit is_read);

           option.per_instance = 1;
           option.name = name; 

           ADDR: coverpoint addr {
            bins STATUS = { 32'h0 };
            bins CLKDIV = { 32'h4 };
            bins SPICMD = { 32'h8 };
            bins SPIADR = { 32'hc };
            bins SPILEN = { 32'h10 };
            bins SPIDUM = { 32'h14 };
            bins TXFIFO = { 32'h18 };
            bins RXFIFO = { 32'h20 };
            bins INTCFG = { 32'h24 };
            }

           RW: coverpoint is_read {
            bins RD = {1};
            bins WR = {0};
            }
           
           ACCESS: cross ADDR, RW {
            ignore_bins READ_ONLY_RXFIFO = binsof(ADDR) intersect { 32'h20 } && binsof(RW) intersect {0};
            }

        endgroup : ra_cov

        // Function: new
        function new(string name = "spi_master_apb_if_coverage");
           ra_cov = new(name);
        endfunction : new

        // Function: sample
        function void sample(uvm_reg_addr_t offset, bit is_read);
           ra_cov.sample(offset, is_read);
        endfunction : sample
        
    endclass : spi_master_apb_if_coverage

    //-----------------------------------------------------------------------------
    // Addrmap - spi_master_apb_if
    //-----------------------------------------------------------------------------
    class spi_master_apb_if extends uvm_reg_block;
        `uvm_object_utils(spi_master_apb_if)

        rand spi_master_apb_if__status STATUS;
        rand spi_master_apb_if__clkdiv CLKDIV;
        rand spi_master_apb_if__spicmd SPICMD;
        rand spi_master_apb_if__spiadr SPIADR;
        rand spi_master_apb_if__spilen SPILEN;
        rand spi_master_apb_if__spidum SPIDUM;
        rand spi_master_apb_if__txfifo TXFIFO;
        rand spi_master_apb_if__rxfifo RXFIFO;
        rand spi_master_apb_if__intcfg INTCFG;

        spi_master_apb_if_coverage spi_master_apb_if_cg;

        // Function: new 
        function new(string name = "spi_master_apb_if");
            super.new(name, build_coverage(UVM_CVR_ALL));
        endfunction : new

        // Function: build
        virtual function void build();
            this.default_map = create_map(.name("SPI_MASTER_MAP_ABP_IF"),
                                          .base_addr(32'h1a102000), 
                                          .n_bytes(4), 
                                          .endian(UVM_LITTLE_ENDIAN));

            this.add_hdl_path("None");

            if(has_coverage(UVM_CVR_ADDR_MAP)) begin
              spi_master_apb_if_cg = spi_master_apb_if_coverage::type_id::create("spi_master_apb_if_cg");
              spi_master_apb_if_cg.ra_cov.set_inst_name(this.get_full_name());
              void'(set_coverage(UVM_CVR_ADDR_MAP));
            end
            
            this.STATUS = spi_master_apb_if__status::type_id::create("STATUS");
            this.STATUS.configure(this);

            this.STATUS.build();
            this.default_map.add_reg(.rg(this.STATUS), .offset(32'h0), .rights("RW"));

            this.CLKDIV = spi_master_apb_if__clkdiv::type_id::create("CLKDIV");
            this.CLKDIV.configure(this);

            this.CLKDIV.build();
            this.default_map.add_reg(.rg(this.CLKDIV), .offset(32'h4), .rights("RW"));

            this.SPICMD = spi_master_apb_if__spicmd::type_id::create("SPICMD");
            this.SPICMD.configure(this);

            this.SPICMD.build();
            this.default_map.add_reg(.rg(this.SPICMD), .offset(32'h8), .rights("RW"));

            this.SPIADR = spi_master_apb_if__spiadr::type_id::create("SPIADR");
            this.SPIADR.configure(this);

            this.SPIADR.build();
            this.default_map.add_reg(.rg(this.SPIADR), .offset(32'hc), .rights("RW"));

            this.SPILEN = spi_master_apb_if__spilen::type_id::create("SPILEN");
            this.SPILEN.configure(this);

            this.SPILEN.build();
            this.default_map.add_reg(.rg(this.SPILEN), .offset(32'h10), .rights("RW"));

            this.SPIDUM = spi_master_apb_if__spidum::type_id::create("SPIDUM");
            this.SPIDUM.configure(this);

            this.SPIDUM.build();
            this.default_map.add_reg(.rg(this.SPIDUM), .offset(32'h14), .rights("RW"));

            this.TXFIFO = spi_master_apb_if__txfifo::type_id::create("TXFIFO");
            this.TXFIFO.configure(this);

            this.TXFIFO.build();
            this.default_map.add_reg(.rg(this.TXFIFO), .offset(32'h18), .rights("WO"));

            this.RXFIFO = spi_master_apb_if__rxfifo::type_id::create("RXFIFO");
            this.RXFIFO.configure(this);

            this.RXFIFO.build();
            this.default_map.add_reg(.rg(this.RXFIFO), .offset(32'h20), .rights("RO"));

            this.INTCFG = spi_master_apb_if__intcfg::type_id::create("INTCFG");
            this.INTCFG.configure(this);

            this.INTCFG.build();
            this.default_map.add_reg(.rg(this.INTCFG), .offset(32'h24), .rights("RW"));

        endfunction : build
        
        // Function: sample
        protected virtual function void sample(uvm_reg_addr_t offset, bit is_read, uvm_reg_map  map);
            if(get_coverage(UVM_CVR_ADDR_MAP)) begin
               if(map.get_name() == "SPI_MASTER_MAP_ABP_IF") begin
                  spi_master_apb_if_cg.sample(offset, is_read);
               end
            end
        endfunction: sample

    endclass : spi_master_apb_if

endpackage: spi_master_uvm_pkg
